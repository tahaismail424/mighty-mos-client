{"ast":null,"code":"import { getHeader } from './httpHeaders.js';\n/**\r\n * An enum to override retries for any endpoint.\r\n */\n\nvar RequestRetryOption;\n(function (RequestRetryOption) {\n  RequestRetryOption[RequestRetryOption[\"Enable\"] = 0] = \"Enable\";\n  RequestRetryOption[RequestRetryOption[\"Disable\"] = 1] = \"Disable\";\n  RequestRetryOption[RequestRetryOption[\"Default\"] = 2] = \"Default\";\n})(RequestRetryOption || (RequestRetryOption = {}));\n/**\r\n * Returns wait time for the request\r\n * @param retryConfig Configuration for retry\r\n * @param method HttpMethod of the request\r\n * @param allowedWaitTime Remaining allowed wait time\r\n * @param retryCount Retry attempt number\r\n * @param httpCode Status code received\r\n * @param headers Response headers\r\n * @param timeoutError Error from the server\r\n * @returns Wait time before the retry\r\n */\n\nfunction getRetryWaitTime(retryConfig, allowedWaitTime, retryCount, httpCode, headers, timeoutError) {\n  var retryWaitTime = 0.0;\n  var retry = false;\n  var retryAfter = 0;\n  if (retryCount < retryConfig.maxNumberOfRetries) {\n    if (timeoutError) {\n      retry = retryConfig.retryOnTimeout;\n    } else if (typeof headers !== 'undefined' && typeof httpCode !== 'undefined') {\n      retryAfter = getRetryAfterSeconds(getHeader(headers, 'retry-after'));\n      retry = retryAfter > 0 || retryConfig.httpStatusCodesToRetry.includes(httpCode);\n    }\n    if (retry) {\n      var noise = +(Math.random() / 100).toFixed(3);\n      var waitTime = retryConfig.retryInterval * Math.pow(retryConfig.backoffFactor, retryCount) + noise;\n      waitTime = Math.max(waitTime, retryAfter);\n      if (waitTime <= allowedWaitTime) {\n        retryWaitTime = waitTime;\n      }\n    }\n  }\n  return retryWaitTime;\n}\nfunction getRetryAfterSeconds(retryAfter) {\n  if (retryAfter == null) {\n    return 0;\n  }\n  if (isNaN(+retryAfter)) {\n    var timeDifference = (new Date(retryAfter).getTime() - Date.now()) / 1000;\n    return isNaN(timeDifference) ? 0 : timeDifference;\n  }\n  return +retryAfter;\n}\nfunction shouldRetryRequest(retryConfig, retryOption, httpMethod) {\n  switch (retryOption) {\n    case RequestRetryOption.Default:\n      return retryConfig.httpMethodsToRetry.includes(httpMethod);\n    case RequestRetryOption.Enable:\n      return true;\n    case RequestRetryOption.Disable:\n      return false;\n  }\n}\nexport { RequestRetryOption, getRetryWaitTime, shouldRetryRequest };","map":{"version":3,"names":["getHeader","RequestRetryOption","getRetryWaitTime","retryConfig","allowedWaitTime","retryCount","httpCode","headers","timeoutError","retryWaitTime","retry","retryAfter","maxNumberOfRetries","retryOnTimeout","getRetryAfterSeconds","httpStatusCodesToRetry","includes","noise","Math","random","toFixed","waitTime","retryInterval","pow","backoffFactor","max","isNaN","timeDifference","Date","getTime","now","shouldRetryRequest","retryOption","httpMethod","Default","httpMethodsToRetry","Enable","Disable"],"sources":["/Users/tahaismail/web_projects/mighty_mos/client/node_modules/@apimatic/core/es/http/retryConfiguration.js"],"sourcesContent":["import { getHeader } from './httpHeaders.js';\n/**\r\n * An enum to override retries for any endpoint.\r\n */\n\nvar RequestRetryOption;\n\n(function (RequestRetryOption) {\n  RequestRetryOption[RequestRetryOption[\"Enable\"] = 0] = \"Enable\";\n  RequestRetryOption[RequestRetryOption[\"Disable\"] = 1] = \"Disable\";\n  RequestRetryOption[RequestRetryOption[\"Default\"] = 2] = \"Default\";\n})(RequestRetryOption || (RequestRetryOption = {}));\n/**\r\n * Returns wait time for the request\r\n * @param retryConfig Configuration for retry\r\n * @param method HttpMethod of the request\r\n * @param allowedWaitTime Remaining allowed wait time\r\n * @param retryCount Retry attempt number\r\n * @param httpCode Status code received\r\n * @param headers Response headers\r\n * @param timeoutError Error from the server\r\n * @returns Wait time before the retry\r\n */\n\n\nfunction getRetryWaitTime(retryConfig, allowedWaitTime, retryCount, httpCode, headers, timeoutError) {\n  var retryWaitTime = 0.0;\n  var retry = false;\n  var retryAfter = 0;\n\n  if (retryCount < retryConfig.maxNumberOfRetries) {\n    if (timeoutError) {\n      retry = retryConfig.retryOnTimeout;\n    } else if (typeof headers !== 'undefined' && typeof httpCode !== 'undefined') {\n      retryAfter = getRetryAfterSeconds(getHeader(headers, 'retry-after'));\n      retry = retryAfter > 0 || retryConfig.httpStatusCodesToRetry.includes(httpCode);\n    }\n\n    if (retry) {\n      var noise = +(Math.random() / 100).toFixed(3);\n      var waitTime = retryConfig.retryInterval * Math.pow(retryConfig.backoffFactor, retryCount) + noise;\n      waitTime = Math.max(waitTime, retryAfter);\n\n      if (waitTime <= allowedWaitTime) {\n        retryWaitTime = waitTime;\n      }\n    }\n  }\n\n  return retryWaitTime;\n}\n\nfunction getRetryAfterSeconds(retryAfter) {\n  if (retryAfter == null) {\n    return 0;\n  }\n\n  if (isNaN(+retryAfter)) {\n    var timeDifference = (new Date(retryAfter).getTime() - Date.now()) / 1000;\n    return isNaN(timeDifference) ? 0 : timeDifference;\n  }\n\n  return +retryAfter;\n}\n\nfunction shouldRetryRequest(retryConfig, retryOption, httpMethod) {\n  switch (retryOption) {\n    case RequestRetryOption.Default:\n      return retryConfig.httpMethodsToRetry.includes(httpMethod);\n\n    case RequestRetryOption.Enable:\n      return true;\n\n    case RequestRetryOption.Disable:\n      return false;\n  }\n}\n\nexport { RequestRetryOption, getRetryWaitTime, shouldRetryRequest };"],"mappings":"AAAA,SAASA,SAAS,QAAQ,kBAAkB;AAC5C;AACA;AACA;;AAEA,IAAIC,kBAAkB;AAEtB,CAAC,UAAUA,kBAAkB,EAAE;EAC7BA,kBAAkB,CAACA,kBAAkB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EAC/DA,kBAAkB,CAACA,kBAAkB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACjEA,kBAAkB,CAACA,kBAAkB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;AACnE,CAAC,EAAEA,kBAAkB,KAAKA,kBAAkB,GAAG,CAAC,CAAC,CAAC,CAAC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASC,gBAAgBA,CAACC,WAAW,EAAEC,eAAe,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,YAAY,EAAE;EACnG,IAAIC,aAAa,GAAG,GAAG;EACvB,IAAIC,KAAK,GAAG,KAAK;EACjB,IAAIC,UAAU,GAAG,CAAC;EAElB,IAAIN,UAAU,GAAGF,WAAW,CAACS,kBAAkB,EAAE;IAC/C,IAAIJ,YAAY,EAAE;MAChBE,KAAK,GAAGP,WAAW,CAACU,cAAc;IACpC,CAAC,MAAM,IAAI,OAAON,OAAO,KAAK,WAAW,IAAI,OAAOD,QAAQ,KAAK,WAAW,EAAE;MAC5EK,UAAU,GAAGG,oBAAoB,CAACd,SAAS,CAACO,OAAO,EAAE,aAAa,CAAC,CAAC;MACpEG,KAAK,GAAGC,UAAU,GAAG,CAAC,IAAIR,WAAW,CAACY,sBAAsB,CAACC,QAAQ,CAACV,QAAQ,CAAC;IACjF;IAEA,IAAII,KAAK,EAAE;MACT,IAAIO,KAAK,GAAG,CAAC,CAACC,IAAI,CAACC,MAAM,EAAE,GAAG,GAAG,EAAEC,OAAO,CAAC,CAAC,CAAC;MAC7C,IAAIC,QAAQ,GAAGlB,WAAW,CAACmB,aAAa,GAAGJ,IAAI,CAACK,GAAG,CAACpB,WAAW,CAACqB,aAAa,EAAEnB,UAAU,CAAC,GAAGY,KAAK;MAClGI,QAAQ,GAAGH,IAAI,CAACO,GAAG,CAACJ,QAAQ,EAAEV,UAAU,CAAC;MAEzC,IAAIU,QAAQ,IAAIjB,eAAe,EAAE;QAC/BK,aAAa,GAAGY,QAAQ;MAC1B;IACF;EACF;EAEA,OAAOZ,aAAa;AACtB;AAEA,SAASK,oBAAoBA,CAACH,UAAU,EAAE;EACxC,IAAIA,UAAU,IAAI,IAAI,EAAE;IACtB,OAAO,CAAC;EACV;EAEA,IAAIe,KAAK,CAAC,CAACf,UAAU,CAAC,EAAE;IACtB,IAAIgB,cAAc,GAAG,CAAC,IAAIC,IAAI,CAACjB,UAAU,CAAC,CAACkB,OAAO,EAAE,GAAGD,IAAI,CAACE,GAAG,EAAE,IAAI,IAAI;IACzE,OAAOJ,KAAK,CAACC,cAAc,CAAC,GAAG,CAAC,GAAGA,cAAc;EACnD;EAEA,OAAO,CAAChB,UAAU;AACpB;AAEA,SAASoB,kBAAkBA,CAAC5B,WAAW,EAAE6B,WAAW,EAAEC,UAAU,EAAE;EAChE,QAAQD,WAAW;IACjB,KAAK/B,kBAAkB,CAACiC,OAAO;MAC7B,OAAO/B,WAAW,CAACgC,kBAAkB,CAACnB,QAAQ,CAACiB,UAAU,CAAC;IAE5D,KAAKhC,kBAAkB,CAACmC,MAAM;MAC5B,OAAO,IAAI;IAEb,KAAKnC,kBAAkB,CAACoC,OAAO;MAC7B,OAAO,KAAK;EAAC;AAEnB;AAEA,SAASpC,kBAAkB,EAAEC,gBAAgB,EAAE6B,kBAAkB"},"metadata":{},"sourceType":"module","externalDependencies":[]}