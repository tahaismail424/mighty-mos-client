{"ast":null,"code":"import { __spreadArray, __read } from 'tslib';\nimport { objectEntries } from '../utils.js';\n/**\r\n * Create a dictionary schema.\r\n *\r\n * This can be used to map/unmap a type like Record<string, something>.\r\n */\n\nfunction dict(itemSchema) {\n  var validate = function (validateFn, value, ctxt) {\n    if (typeof value !== 'object' || value === null) {\n      return ctxt.fail();\n    }\n    var valueObject = value;\n    return ctxt.flatmapChildren(objectEntries(valueObject), itemSchema, function (v, childCtxt) {\n      return itemSchema[validateFn](v[1], childCtxt);\n    });\n  };\n  return {\n    type: function () {\n      return \"Record<string,\" + itemSchema.type() + \">\";\n    },\n    validateBeforeMap: function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return validate.apply(void 0, __spreadArray(['validateBeforeMap'], __read(args)));\n    },\n    validateBeforeUnmap: function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return validate.apply(void 0, __spreadArray(['validateBeforeUnmap'], __read(args)));\n    },\n    map: function (value, ctxt) {\n      var output = {};\n      for (var key in value) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\n          var propValue = value[key];\n          output[key] = itemSchema.map(propValue, ctxt.createChild(key, propValue, itemSchema));\n        }\n      }\n      return output;\n    },\n    unmap: function (value, ctxt) {\n      var output = {};\n      for (var key in value) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\n          var propValue = value[key];\n          output[key] = itemSchema.unmap(propValue, ctxt.createChild(key, propValue, itemSchema));\n        }\n      }\n      return output;\n    },\n    validateBeforeMapXml: function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return validate.apply(void 0, __spreadArray(['validateBeforeMapXml'], __read(args)));\n    },\n    mapXml: function (value, ctxt) {\n      var output = {};\n      for (var key in value) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\n          var propValue = value[key];\n          output[key] = itemSchema.mapXml(propValue, ctxt.createChild(key, propValue, itemSchema));\n        }\n      }\n      return output;\n    },\n    unmapXml: function (value, ctxt) {\n      var output = {};\n      for (var key in value) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\n          var propValue = value[key];\n          output[key] = itemSchema.unmapXml(propValue, ctxt.createChild(key, propValue, itemSchema));\n        }\n      }\n      return output;\n    }\n  };\n}\nexport { dict };","map":{"version":3,"names":["__spreadArray","__read","objectEntries","dict","itemSchema","validate","validateFn","value","ctxt","fail","valueObject","flatmapChildren","v","childCtxt","type","validateBeforeMap","args","_i","arguments","length","apply","validateBeforeUnmap","map","output","key","Object","prototype","hasOwnProperty","call","propValue","createChild","unmap","validateBeforeMapXml","mapXml","unmapXml"],"sources":["/Users/tahaismail/web_projects/mighty_mos/client/node_modules/@apimatic/schema/es/types/dict.js"],"sourcesContent":["import { __spreadArray, __read } from 'tslib';\nimport { objectEntries } from '../utils.js';\n/**\r\n * Create a dictionary schema.\r\n *\r\n * This can be used to map/unmap a type like Record<string, something>.\r\n */\n\nfunction dict(itemSchema) {\n  var validate = function (validateFn, value, ctxt) {\n    if (typeof value !== 'object' || value === null) {\n      return ctxt.fail();\n    }\n\n    var valueObject = value;\n    return ctxt.flatmapChildren(objectEntries(valueObject), itemSchema, function (v, childCtxt) {\n      return itemSchema[validateFn](v[1], childCtxt);\n    });\n  };\n\n  return {\n    type: function () {\n      return \"Record<string,\" + itemSchema.type() + \">\";\n    },\n    validateBeforeMap: function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return validate.apply(void 0, __spreadArray(['validateBeforeMap'], __read(args)));\n    },\n    validateBeforeUnmap: function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return validate.apply(void 0, __spreadArray(['validateBeforeUnmap'], __read(args)));\n    },\n    map: function (value, ctxt) {\n      var output = {};\n\n      for (var key in value) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\n          var propValue = value[key];\n          output[key] = itemSchema.map(propValue, ctxt.createChild(key, propValue, itemSchema));\n        }\n      }\n\n      return output;\n    },\n    unmap: function (value, ctxt) {\n      var output = {};\n\n      for (var key in value) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\n          var propValue = value[key];\n          output[key] = itemSchema.unmap(propValue, ctxt.createChild(key, propValue, itemSchema));\n        }\n      }\n\n      return output;\n    },\n    validateBeforeMapXml: function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return validate.apply(void 0, __spreadArray(['validateBeforeMapXml'], __read(args)));\n    },\n    mapXml: function (value, ctxt) {\n      var output = {};\n\n      for (var key in value) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\n          var propValue = value[key];\n          output[key] = itemSchema.mapXml(propValue, ctxt.createChild(key, propValue, itemSchema));\n        }\n      }\n\n      return output;\n    },\n    unmapXml: function (value, ctxt) {\n      var output = {};\n\n      for (var key in value) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\n          var propValue = value[key];\n          output[key] = itemSchema.unmapXml(propValue, ctxt.createChild(key, propValue, itemSchema));\n        }\n      }\n\n      return output;\n    }\n  };\n}\n\nexport { dict };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}