{"ast":null,"code":"import { __assign, __read, __values } from 'tslib';\nimport { objectEntries } from '../utils.js';\nimport { dict } from './dict.js';\nfunction dictWithXmlEntries(itemSchema) {\n  var dictSchema = dict(itemSchema);\n  var modifiedSchema = __assign({}, dictSchema);\n  modifiedSchema.unmapXml = function (inputValue, ctxt) {\n    var output = dictSchema.unmapXml(inputValue, ctxt); // Convert each entry to XML \"entry\" elements. The XML \"entry\" element looks\n    // like this: `<entry key=\"key\">value</entry>`. Note that the element name\n    // \"entry\" is set later at the return.\n\n    var entries = objectEntries(output).map(function (_a) {\n      var _b = __read(_a, 2),\n        key = _b[0],\n        value = _b[1];\n      return {\n        $: {\n          key: key\n        },\n        _: value\n      };\n    });\n    return {\n      entry: entries\n    };\n  };\n  modifiedSchema.mapXml = function (value, ctxt) {\n    var e_1, _a; // Empty dictionary\n\n    if (!('entry' in value)) {\n      return {};\n    }\n    var entries = value.entry; // For a single entry, the XML parser gives a single object instead of an array.\n    // Make it an array for easier handling.\n\n    if (!Array.isArray(entries)) {\n      entries = [entries];\n    } // Convert entry elements containing a key attribute and content to a dictionary.\n\n    var dictObj = {};\n    try {\n      for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {\n        var item = entries_1_1.value;\n        dictObj[item.$.key] = item._;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // Run validation on entry values against the item schema.\n    // TODO: Maintain context and path when delegating validatin\n\n    return dictSchema.mapXml(dictObj, ctxt);\n  };\n  modifiedSchema.validateBeforeMapXml = function (value, ctxt) {\n    var e_2, _a;\n    if (typeof value !== 'object' || value === null) {\n      return ctxt.fail();\n    } // Empty dictionary case\n\n    if (!('entry' in value)) {\n      return [];\n    }\n    var entries = value.entry; // Non-repeating XML elements are passed as a single-object instead of an array of objects.\n    // We normalize this behavior of the XML parser.\n\n    if (!Array.isArray(entries)) {\n      entries = [entries];\n    } // Dictionary for all entries\n\n    var dictObj = {};\n    try {\n      for (var entries_2 = __values(entries), entries_2_1 = entries_2.next(); !entries_2_1.done; entries_2_1 = entries_2.next()) {\n        var entry = entries_2_1.value; // Fail if entry is not an XML element object.\n\n        if (typeof entry !== 'object' || entry === null) {\n          return ctxt.fail('Expected \"entry\" to be an XML element.');\n        } // Fail if entry does not have an attribute named key.\n\n        if (!('$' in entry) || !('key' in entry.$)) {\n          return ctxt.fail('Expected \"entry\" element to have an attribute named \"key\".');\n        } // Set entry in dictionary\n\n        var typedEntry = entry;\n        dictObj[typedEntry.$.key] = typedEntry._;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (entries_2_1 && !entries_2_1.done && (_a = entries_2.return)) _a.call(entries_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    } // Check all entry values against the item schema.\n    // TODO: Maintain context and path when delegating validation\n\n    return dictSchema.validateBeforeMapXml(dictObj, ctxt);\n  };\n  return modifiedSchema;\n}\nexport { dictWithXmlEntries };","map":{"version":3,"names":["__assign","__read","__values","objectEntries","dict","dictWithXmlEntries","itemSchema","dictSchema","modifiedSchema","unmapXml","inputValue","ctxt","output","entries","map","_a","_b","key","value","$","_","entry","mapXml","e_1","Array","isArray","dictObj","entries_1","entries_1_1","next","done","item","e_1_1","error","return","call","validateBeforeMapXml","e_2","fail","entries_2","entries_2_1","typedEntry","e_2_1"],"sources":["/Users/tahaismail/web_projects/mighty_mos/client/node_modules/@apimatic/schema/es/types/dictWithXmlEntries.js"],"sourcesContent":["import { __assign, __read, __values } from 'tslib';\nimport { objectEntries } from '../utils.js';\nimport { dict } from './dict.js';\n\nfunction dictWithXmlEntries(itemSchema) {\n  var dictSchema = dict(itemSchema);\n\n  var modifiedSchema = __assign({}, dictSchema);\n\n  modifiedSchema.unmapXml = function (inputValue, ctxt) {\n    var output = dictSchema.unmapXml(inputValue, ctxt); // Convert each entry to XML \"entry\" elements. The XML \"entry\" element looks\n    // like this: `<entry key=\"key\">value</entry>`. Note that the element name\n    // \"entry\" is set later at the return.\n\n    var entries = objectEntries(output).map(function (_a) {\n      var _b = __read(_a, 2),\n          key = _b[0],\n          value = _b[1];\n\n      return {\n        $: {\n          key: key\n        },\n        _: value\n      };\n    });\n    return {\n      entry: entries\n    };\n  };\n\n  modifiedSchema.mapXml = function (value, ctxt) {\n    var e_1, _a; // Empty dictionary\n\n\n    if (!('entry' in value)) {\n      return {};\n    }\n\n    var entries = value.entry; // For a single entry, the XML parser gives a single object instead of an array.\n    // Make it an array for easier handling.\n\n    if (!Array.isArray(entries)) {\n      entries = [entries];\n    } // Convert entry elements containing a key attribute and content to a dictionary.\n\n\n    var dictObj = {};\n\n    try {\n      for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {\n        var item = entries_1_1.value;\n        dictObj[item.$.key] = item._;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // Run validation on entry values against the item schema.\n    // TODO: Maintain context and path when delegating validatin\n\n\n    return dictSchema.mapXml(dictObj, ctxt);\n  };\n\n  modifiedSchema.validateBeforeMapXml = function (value, ctxt) {\n    var e_2, _a;\n\n    if (typeof value !== 'object' || value === null) {\n      return ctxt.fail();\n    } // Empty dictionary case\n\n\n    if (!('entry' in value)) {\n      return [];\n    }\n\n    var entries = value.entry; // Non-repeating XML elements are passed as a single-object instead of an array of objects.\n    // We normalize this behavior of the XML parser.\n\n    if (!Array.isArray(entries)) {\n      entries = [entries];\n    } // Dictionary for all entries\n\n\n    var dictObj = {};\n\n    try {\n      for (var entries_2 = __values(entries), entries_2_1 = entries_2.next(); !entries_2_1.done; entries_2_1 = entries_2.next()) {\n        var entry = entries_2_1.value; // Fail if entry is not an XML element object.\n\n        if (typeof entry !== 'object' || entry === null) {\n          return ctxt.fail('Expected \"entry\" to be an XML element.');\n        } // Fail if entry does not have an attribute named key.\n\n\n        if (!('$' in entry) || !('key' in entry.$)) {\n          return ctxt.fail('Expected \"entry\" element to have an attribute named \"key\".');\n        } // Set entry in dictionary\n\n\n        var typedEntry = entry;\n        dictObj[typedEntry.$.key] = typedEntry._;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (entries_2_1 && !entries_2_1.done && (_a = entries_2.return)) _a.call(entries_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    } // Check all entry values against the item schema.\n    // TODO: Maintain context and path when delegating validation\n\n\n    return dictSchema.validateBeforeMapXml(dictObj, ctxt);\n  };\n\n  return modifiedSchema;\n}\n\nexport { dictWithXmlEntries };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}