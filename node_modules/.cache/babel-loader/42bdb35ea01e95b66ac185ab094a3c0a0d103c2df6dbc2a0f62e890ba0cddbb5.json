{"ast":null,"code":"import { __assign } from 'tslib';\n/**\r\n * Utilities for internal library usage\r\n */\n\nfunction arrayEntries(arr) {\n  var entries = [];\n  for (var index = 0; index < arr.length; index++) {\n    var element = arr[index];\n    entries.push([index, element]);\n  }\n  return entries;\n}\nfunction objectEntries(obj) {\n  var ownProps = Object.keys(obj);\n  var i = ownProps.length;\n  var resArray = new Array(i); // preallocate the Array\n\n  while (i--) {\n    resArray[i] = [ownProps[i], obj[ownProps[i]]];\n  }\n  return resArray;\n}\nfunction literalToString(value) {\n  return typeof value === 'string' ? \"\\\"\" + value.replace(/\"/g, '\"') + \"\\\"\" : \"\" + value;\n}\nfunction identityFn(value) {\n  return value;\n}\nfunction toValidator(fn) {\n  return function (value, ctxt) {\n    return fn(value) ? [] : ctxt.fail();\n  };\n}\n/**\r\n * Create a schema in which the mapping and unmapping is done the same way\r\n */\n\nfunction createSymmetricSchema(schema) {\n  return createBasicSchema({\n    type: function () {\n      return schema.type;\n    },\n    validateBeforeMap: schema.validate,\n    validateBeforeUnmap: schema.validate,\n    map: schema.map,\n    unmap: schema.map\n  });\n}\n/** Create a basic schema where XML mapping and validation is the same as for JSON */\n\nfunction createBasicSchema(basicSchema) {\n  return __assign(__assign({}, basicSchema), {\n    validateBeforeMapXml: basicSchema.validateBeforeUnmap,\n    mapXml: basicSchema.map,\n    unmapXml: basicSchema.unmap\n  });\n}\nfunction isNumericString(value) {\n  return typeof value === 'number' || typeof value === 'string' && !isNaN(value);\n}\nfunction coerceNumericStringToNumber(value) {\n  return typeof value === 'number' ? value : +value;\n}\nfunction coerceStringOrNumberToBigInt(value) {\n  return typeof value === 'bigint' ? value : BigInt(value);\n}\nfunction once(func) {\n  var ran = false;\n  var memo;\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (ran) {\n      return memo;\n    }\n    ran = true;\n    memo = func.apply(this, args);\n    return memo;\n  };\n}\n/**\r\n * Returns a copy of the object with the given keys omitted.\r\n */\n\nfunction omitKeysFromObject(object, keysToOmit) {\n  var omitSet = new Set(keysToOmit);\n  var output = {};\n  for (var key in object) {\n    if (Object.prototype.hasOwnProperty.call(object, key) && !omitSet.has(key)) {\n      output[key] = object[key];\n    }\n  }\n  return output;\n}\nfunction objectKeyEncode(key) {\n  return key.indexOf(' ') !== -1 ? literalToString(key) : key;\n}\nexport { arrayEntries, coerceNumericStringToNumber, coerceStringOrNumberToBigInt, createSymmetricSchema, identityFn, isNumericString, literalToString, objectEntries, objectKeyEncode, omitKeysFromObject, once, toValidator };","map":{"version":3,"names":["__assign","arrayEntries","arr","entries","index","length","element","push","objectEntries","obj","ownProps","Object","keys","i","resArray","Array","literalToString","value","replace","identityFn","toValidator","fn","ctxt","fail","createSymmetricSchema","schema","createBasicSchema","type","validateBeforeMap","validate","validateBeforeUnmap","map","unmap","basicSchema","validateBeforeMapXml","mapXml","unmapXml","isNumericString","isNaN","coerceNumericStringToNumber","coerceStringOrNumberToBigInt","BigInt","once","func","ran","memo","args","_i","arguments","apply","omitKeysFromObject","object","keysToOmit","omitSet","Set","output","key","prototype","hasOwnProperty","call","has","objectKeyEncode","indexOf"],"sources":["/Users/tahaismail/web_projects/mighty_mos/client/node_modules/@apimatic/schema/es/utils.js"],"sourcesContent":["import { __assign } from 'tslib';\n/**\r\n * Utilities for internal library usage\r\n */\n\nfunction arrayEntries(arr) {\n  var entries = [];\n\n  for (var index = 0; index < arr.length; index++) {\n    var element = arr[index];\n    entries.push([index, element]);\n  }\n\n  return entries;\n}\n\nfunction objectEntries(obj) {\n  var ownProps = Object.keys(obj);\n  var i = ownProps.length;\n  var resArray = new Array(i); // preallocate the Array\n\n  while (i--) {\n    resArray[i] = [ownProps[i], obj[ownProps[i]]];\n  }\n\n  return resArray;\n}\n\nfunction literalToString(value) {\n  return typeof value === 'string' ? \"\\\"\" + value.replace(/\"/g, '\"') + \"\\\"\" : \"\" + value;\n}\n\nfunction identityFn(value) {\n  return value;\n}\n\nfunction toValidator(fn) {\n  return function (value, ctxt) {\n    return fn(value) ? [] : ctxt.fail();\n  };\n}\n/**\r\n * Create a schema in which the mapping and unmapping is done the same way\r\n */\n\n\nfunction createSymmetricSchema(schema) {\n  return createBasicSchema({\n    type: function () {\n      return schema.type;\n    },\n    validateBeforeMap: schema.validate,\n    validateBeforeUnmap: schema.validate,\n    map: schema.map,\n    unmap: schema.map\n  });\n}\n/** Create a basic schema where XML mapping and validation is the same as for JSON */\n\n\nfunction createBasicSchema(basicSchema) {\n  return __assign(__assign({}, basicSchema), {\n    validateBeforeMapXml: basicSchema.validateBeforeUnmap,\n    mapXml: basicSchema.map,\n    unmapXml: basicSchema.unmap\n  });\n}\n\nfunction isNumericString(value) {\n  return typeof value === 'number' || typeof value === 'string' && !isNaN(value);\n}\n\nfunction coerceNumericStringToNumber(value) {\n  return typeof value === 'number' ? value : +value;\n}\n\nfunction coerceStringOrNumberToBigInt(value) {\n  return typeof value === 'bigint' ? value : BigInt(value);\n}\n\nfunction once(func) {\n  var ran = false;\n  var memo;\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (ran) {\n      return memo;\n    }\n\n    ran = true;\n    memo = func.apply(this, args);\n    return memo;\n  };\n}\n/**\r\n * Returns a copy of the object with the given keys omitted.\r\n */\n\n\nfunction omitKeysFromObject(object, keysToOmit) {\n  var omitSet = new Set(keysToOmit);\n  var output = {};\n\n  for (var key in object) {\n    if (Object.prototype.hasOwnProperty.call(object, key) && !omitSet.has(key)) {\n      output[key] = object[key];\n    }\n  }\n\n  return output;\n}\n\nfunction objectKeyEncode(key) {\n  return key.indexOf(' ') !== -1 ? literalToString(key) : key;\n}\n\nexport { arrayEntries, coerceNumericStringToNumber, coerceStringOrNumberToBigInt, createSymmetricSchema, identityFn, isNumericString, literalToString, objectEntries, objectKeyEncode, omitKeysFromObject, once, toValidator };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}