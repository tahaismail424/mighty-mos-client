{"ast":null,"code":"import { arrayEntries } from '../utils.js';\n/**\r\n * Create an array schema.\r\n *\r\n * The array must be a homogenous array confirming to the itemsSchema. Each item\r\n * will be mapped/unmapped using the itemsSchema.\r\n */\n\nfunction array(itemsSchema, xmlOptions) {\n  var arraySchema;\n  arraySchema = {\n    type: function () {\n      return \"Array<\" + itemsSchema.type() + \">\";\n    },\n    validateBeforeMap: function (value, ctxt) {\n      return Array.isArray(value) ? ctxt.flatmapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.validateBeforeMap(v[1], childCtxt);\n      }) : ctxt.fail();\n    },\n    validateBeforeUnmap: function (value, ctxt) {\n      return Array.isArray(value) ? ctxt.flatmapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.validateBeforeUnmap(v[1], childCtxt);\n      }) : ctxt.fail();\n    },\n    map: function (value, ctxt) {\n      return ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.map(v[1], childCtxt);\n      });\n    },\n    unmap: function (value, ctxt) {\n      return ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.unmap(v[1], childCtxt);\n      });\n    },\n    mapXml: function (value, ctxt) {\n      var items = value;\n      if (xmlOptions === null || xmlOptions === void 0 ? void 0 : xmlOptions.xmlItemName) {\n        items = value[xmlOptions.xmlItemName];\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\n      }\n      return ctxt.mapChildren(arrayEntries(items), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.mapXml(v[1], childCtxt);\n      });\n    },\n    unmapXml: function (value, ctxt) {\n      var _a;\n      var items = ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.unmapXml(v[1], childCtxt);\n      });\n      if (xmlOptions === null || xmlOptions === void 0 ? void 0 : xmlOptions.xmlItemName) {\n        return _a = {}, _a[xmlOptions.xmlItemName] = items, _a;\n      } else {\n        return items;\n      }\n    },\n    validateBeforeMapXml: function (value, ctxt) {\n      var items = value;\n      if (xmlOptions === null || xmlOptions === void 0 ? void 0 : xmlOptions.xmlItemName) {\n        var errorMessage = \"Expected array to be wrapped with XML element \" + xmlOptions.xmlItemName + \".\";\n        if (typeof value !== 'object' || value === null || !(xmlOptions.xmlItemName in value)) {\n          return ctxt.fail(errorMessage);\n        }\n        items = value[xmlOptions.xmlItemName];\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\n      }\n      return Array.isArray(items) ? ctxt.flatmapChildren(arrayEntries(items), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.validateBeforeMapXml(v[1], childCtxt);\n      }) : ctxt.fail();\n    }\n  };\n  return arraySchema;\n}\nexport { array };","map":{"version":3,"names":["arrayEntries","array","itemsSchema","xmlOptions","arraySchema","type","validateBeforeMap","value","ctxt","Array","isArray","flatmapChildren","v","childCtxt","fail","validateBeforeUnmap","map","mapChildren","unmap","mapXml","items","xmlItemName","createChild","unmapXml","_a","validateBeforeMapXml","errorMessage"],"sources":["/Users/tahaismail/web_projects/mighty_mos/client/node_modules/@apimatic/schema/es/types/array.js"],"sourcesContent":["import { arrayEntries } from '../utils.js';\n/**\r\n * Create an array schema.\r\n *\r\n * The array must be a homogenous array confirming to the itemsSchema. Each item\r\n * will be mapped/unmapped using the itemsSchema.\r\n */\n\nfunction array(itemsSchema, xmlOptions) {\n  var arraySchema;\n  arraySchema = {\n    type: function () {\n      return \"Array<\" + itemsSchema.type() + \">\";\n    },\n    validateBeforeMap: function (value, ctxt) {\n      return Array.isArray(value) ? ctxt.flatmapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.validateBeforeMap(v[1], childCtxt);\n      }) : ctxt.fail();\n    },\n    validateBeforeUnmap: function (value, ctxt) {\n      return Array.isArray(value) ? ctxt.flatmapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.validateBeforeUnmap(v[1], childCtxt);\n      }) : ctxt.fail();\n    },\n    map: function (value, ctxt) {\n      return ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.map(v[1], childCtxt);\n      });\n    },\n    unmap: function (value, ctxt) {\n      return ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.unmap(v[1], childCtxt);\n      });\n    },\n    mapXml: function (value, ctxt) {\n      var items = value;\n\n      if (xmlOptions === null || xmlOptions === void 0 ? void 0 : xmlOptions.xmlItemName) {\n        items = value[xmlOptions.xmlItemName];\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\n      }\n\n      return ctxt.mapChildren(arrayEntries(items), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.mapXml(v[1], childCtxt);\n      });\n    },\n    unmapXml: function (value, ctxt) {\n      var _a;\n\n      var items = ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.unmapXml(v[1], childCtxt);\n      });\n\n      if (xmlOptions === null || xmlOptions === void 0 ? void 0 : xmlOptions.xmlItemName) {\n        return _a = {}, _a[xmlOptions.xmlItemName] = items, _a;\n      } else {\n        return items;\n      }\n    },\n    validateBeforeMapXml: function (value, ctxt) {\n      var items = value;\n\n      if (xmlOptions === null || xmlOptions === void 0 ? void 0 : xmlOptions.xmlItemName) {\n        var errorMessage = \"Expected array to be wrapped with XML element \" + xmlOptions.xmlItemName + \".\";\n\n        if (typeof value !== 'object' || value === null || !(xmlOptions.xmlItemName in value)) {\n          return ctxt.fail(errorMessage);\n        }\n\n        items = value[xmlOptions.xmlItemName];\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\n      }\n\n      return Array.isArray(items) ? ctxt.flatmapChildren(arrayEntries(items), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.validateBeforeMapXml(v[1], childCtxt);\n      }) : ctxt.fail();\n    }\n  };\n  return arraySchema;\n}\n\nexport { array };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}